#include "atom_includes.hpp"
struct Object {
    [[>>>]]
};

struct shared_ {
    Object [[>>>]];
    Object& get(std::size_t idx) noexcept {
        return reinterpret_cast<Object*>(this)[idx];
    }
    const Object& get(std::size_t idx) const noexcept {
        return reinterpret_cast<const Object*>(this)[idx];
    }
};

template <class S>
S& operator<<(S& os, const Object& obj) {
    os << [[>>>]];
    return os;
}

template <class S>
S& operator<<(S& os, const shared_& srd) {
    for (unsigned i = 0; i != sizeof(shared_) / sizeof(Object); ++i)
        os << srd.get(i);
    return os;
}

template <class T>
shared_& get_at_time(T& log, double time) {
    double min_diff = time;
    auto it = log.rbegin();
    for (it != log.rend(); ++it) {
        double diff = fabs(time - it->first);
        if (diff < min_diff)
            min_diff = diff;
        else
            return *std::prev(it)->second;
    }
    return *std::prev(it)->second;
}

int main() {
    std::unique_ptr<shared_> srd_(new shared_{
        {[[>>>]]},
    });
    shared_* last_ptr_ = srd_.get();
    types::log<std::pair<double, std::unique_ptr<shared_>>> history;
    std::ofstream output("out.atom");
    [[>>>]]
    for (double time_ = 0; time_ < t;) {
        for (comb_.reset(); [[>>>]]; ++comb_) {
            [[>>>]]
        }
        history.push_back(std::make_pair(time_, std::move(srd_)));
        time_ += step;
    }
}
