#include "atom_includes.hpp"
struct Object {
    [[>>>]]
};

struct shared_ {
    Object [[>>>]];
    Object& get(std::size_t idx) noexcept {
        return reinterpret_cast<Object*>(this)[idx];
    }
    const Object& get(std::size_t idx) const noexcept {
        return reinterpret_cast<const Object*>(this)[idx];
    }
};

template <class S>
S& operator<<(S& os, const Object& obj) {
    os << [[>>>]] << " ";
    os.seekp(-1, std::ios_base::end);
    return os;
}

template <class S>
S& operator<<(S& os, const shared_& srd) {
    for (unsigned i = 0; i != sizeof(shared_) / sizeof(Object); ++i)
        os << srd.get(i) << "; ";
    os.seekp(-1, std::ios_base::end);
    return os;
}

template <class T>
shared_& get_at_time(T& log, double time) {
    auto it = std::lower_bound(log.begin(), log.end(), time,
        [](const typename T::value_type& lhs, double t) { return lhs.first < t; });
    if (it == log.end())
        return *log.back().second;
    else
        return *it->second;
}

template <class T>
shared_& back_get(T& log, std::size_t step) {
    return *(log.end() - step)->second;
}

int main() {
    types::log<std::pair<double, std::unique_ptr<shared_>>> history;
    std::unique_ptr<shared_> srd_(new shared_{
        {[[>>>]]},
    });
    std::ofstream output("out.atom");
    [[>>>]]
    [[>>>]]
    double time_ = 0;
    history.push_back(std::make_pair(time_, std::move(srd_)));
    srd_ = std::make_unique<shared_>();
    time_ += step;
    while (time_ < t) {
        // we must do this at beginning instead of ending, to ensure consistency
        shared_& last_data_ = *history.back().second;
        history.push_back(std::make_pair(time_, std::make_unique<shared_>()));
        shared_& srd_ = *history.back().second;

        comb_.reset();
        do {
            [[>>>]]
        } while (++comb_);

        output << time_ << ": " << srd_ << "\n";

        time_ += step;
    }
}
